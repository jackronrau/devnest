{"graph":{"../../core/dist/index.d.ts":[],"gitHub-oauth-service.ts":[],"github-search-crawler/crawler.ts":["../../../node_modules/.pnpm/crawlee@3.11.1/node_modules/crawlee/index.d.ts","../../core/dist/index.d.ts","github-search-crawler/types.ts"],"github-search-crawler/index.ts":["../../core/dist/index.d.ts","github-search-crawler/crawler.ts","github-search-crawler/popularity-search-service.ts","github-search-crawler/types.ts"],"github-search-crawler/popularity-search-service.ts":["../../core/dist/index.d.ts","github-search-crawler/crawler.ts","github-search-crawler/types.ts","package-checker.ts","popularity.ts"],"github-search-crawler/types.ts":[],"index.ts":["gitHub-oauth-service.ts","github-search-crawler/index.ts","package-checker.ts","popularity.ts"],"package-checker.ts":[],"popularity.ts":[]},"entry":"/cloudide/workspace/toolbox/packages/github/src/index.ts","sep":"/","usedShadcnComponents":[],"usedCoreModules":[],"usedThirdPartyModules":["crawlee"],"commonDirectory":"/cloudide/workspace/toolbox/packages","usedModulesContent":[["/cloudide/workspace/toolbox/packages/github/src/index.ts","export * from \"./popularity\";\nexport * from \"./package-checker\";\nexport * from \"./gitHub-oauth-service\";\nexport * from \"./github-search-crawler\";"],["/cloudide/workspace/toolbox/packages/github/src/popularity.ts","// 热门技术仓库搜索\ntype MatchType = 'full' | 'partial'\n\nexport interface PopularityTech {\n    name: string;\n    packageName: string;\n    matchType: MatchType;\n    category: string;\n}\n\nconst popularTechnologies = [\n    // 前端框架和库\n    { name: \"React\", packageName: \"react\", matchType: 'full', category: \"Frontend Frameworks\" },\n    { name: \"Vue.js\", packageName: \"vue\", matchType: 'full', category: \"Frontend Frameworks\" },\n    { name: \"Svelte\", packageName: \"svelte\", matchType: 'full', category: \"Frontend Frameworks\" },\n    { name: \"Angular\", packageName: \"angular\", matchType: 'full', category: \"Frontend Frameworks\" },\n\n    // 全栈和服务端渲染框架\n    { name: \"Next.js\", packageName: \"next\", matchType: 'full', category: \"Fullstack Frameworks\" },\n    { name: \"Nuxt.js\", packageName: \"nuxt\", matchType: 'full', category: \"Fullstack Frameworks\" },\n    { name: \"Remix\", packageName: \"remix\", matchType: 'full', category: \"Fullstack Frameworks\" },\n    { name: \"SvelteKit\", packageName: \"@sveltejs/kit\", matchType: 'full', category: \"Fullstack Frameworks\" },\n    { name: \"Blitz.js\", packageName: \"blitz\", matchType: 'full', category: \"Fullstack Frameworks\" },\n    { name: \"Astro\", packageName: \"astro\", matchType: 'full', category: \"Fullstack Frameworks\" },\n\n    // 后端框架\n    { name: \"NestJS\", packageName: \"@nestjs/core\", matchType: 'full', category: \"Backend Frameworks\" },\n    { name: \"Express.js\", packageName: \"express\", matchType: 'full', category: \"Backend Frameworks\" },\n    { name: \"Fastify\", packageName: \"fastify\", matchType: 'full', category: \"Backend Frameworks\" },\n\n    // 云服务和部署平台\n    { name: \"Vercel\", packageName: \"@vercel/node\", matchType: 'full', category: \"Cloud Services\" },\n    { name: \"Netlify\", packageName: \"netlify-cli\", matchType: 'full', category: \"Cloud Services\" },\n    { name: \"Cloudflare Workers\", packageName: \"@cloudflare/workers-types\", matchType: 'full', category: \"Cloud Services\" },\n    { name: \"AWS SDK\", packageName: \"aws-sdk\", matchType: 'full', category: \"Cloud Services\" },\n    { name: \"Google Cloud Storage\", packageName: \"@google-cloud/storage\", matchType: 'full', category: \"Cloud Services\" },\n    { name: \"Azure Blob Storage\", packageName: \"@azure/storage-blob\", matchType: 'full', category: \"Cloud Services\" },\n\n    // CSS 框架和工具\n    { name: \"Tailwind CSS\", packageName: \"tailwindcss\", matchType: 'full', category: \"CSS Frameworks\" },\n    { name: \"styled-components\", packageName: \"styled-components\", matchType: 'full', category: \"CSS Frameworks\" },\n    { name: \"Sass\", packageName: \"sass\", matchType: 'full', category: \"CSS Frameworks\" },\n    { name: \"Less\", packageName: \"less\", matchType: 'full', category: \"CSS Frameworks\" },\n\n    // 状态管理\n    { name: \"Redux\", packageName: \"redux\", matchType: 'full', category: \"State Management\" },\n    { name: \"MobX\", packageName: \"mobx\", matchType: 'full', category: \"State Management\" },\n    { name: \"Recoil\", packageName: \"recoil\", matchType: 'full', category: \"State Management\" },\n    { name: \"Zustand\", packageName: \"zustand\", matchType: 'full', category: \"State Management\" },\n    { name: \"Pinia\", packageName: \"pinia\", matchType: 'full', category: \"State Management\" },\n\n    // 认证和授权\n    { name: \"NextAuth.js\", packageName: \"next-auth\", matchType: 'full', category: \"Authentication & Authorization\" },\n    { name: \"Firebase\", packageName: \"firebase\", matchType: 'full', category: \"Authentication & Authorization\" },\n    { name: \"Auth0\", packageName: \"@auth0/auth0-react\", matchType: 'full', category: \"Authentication & Authorization\" },\n    { name: \"Passport.js\", packageName: \"passport\", matchType: 'full', category: \"Authentication & Authorization\" },\n    { name: \"Clerk\", packageName: \"@clerk/clerk-react\", matchType: 'full', category: \"Authentication & Authorization\" },\n\n    // API 开发和管理\n    { name: \"GraphQL\", packageName: \"graphql\", matchType: 'full', category: \"API Technologies\" },\n    { name: \"Apollo Client\", packageName: \"@apollo/client\", matchType: 'full', category: \"API Technologies\" },\n    { name: \"Swagger UI Express\", packageName: \"swagger-ui-express\", matchType: 'full', category: \"API Technologies\" },\n    { name: \"tRPC\", packageName: \"@trpc/server\", matchType: 'full', category: \"API Technologies\" },\n\n    // 数据库和ORM\n    { name: \"Prisma\", packageName: \"@prisma/client\", matchType: 'full', category: \"Database & ORM\" },\n    { name: \"TypeORM\", packageName: \"typeorm\", matchType: 'full', category: \"Database & ORM\" },\n    { name: \"Mongoose\", packageName: \"mongoose\", matchType: 'full', category: \"Database & ORM\" },\n    { name: \"Sequelize\", packageName: \"sequelize\", matchType: 'full', category: \"Database & ORM\" },\n\n    // AI 和机器学习\n    { name: \"TensorFlow.js\", packageName: \"@tensorflow/tfjs\", matchType: 'full', category: \"AI & ML\" },\n    { name: \"OpenAI\", packageName: \"openai\", matchType: 'full', category: \"AI & ML\" },\n    { name: \"Anthropic\", packageName: \"@anthropic-ai/sdk\", matchType: 'full', category: \"AI & ML\" },\n    { name: \"Hugging Face\", packageName: \"@huggingface/inference\", matchType: 'full', category: \"AI & ML\" },\n    { name: \"LangChain\", packageName: \"@langchain/core\", matchType: 'full', category: \"AI & ML\" },\n    { name: \"LangGraph\", packageName: \"@langchain/langgraph\", matchType: 'full', category: \"AI & ML\" },\n\n    // 构建工具\n    { name: \"Webpack\", packageName: \"webpack\", matchType: 'full', category: \"Build Tools\" },\n    { name: \"Vite\", packageName: \"vite\", matchType: 'full', category: \"Build Tools\" },\n\n    // 开发工具\n    { name: \"TypeScript\", packageName: \"typescript\", matchType: 'full', category: \"Developer Tools\" },\n    { name: \"ESLint\", packageName: \"eslint\", matchType: 'full', category: \"Developer Tools\" },\n    { name: \"Prettier\", packageName: \"prettier\", matchType: 'full', category: \"Developer Tools\" },\n\n    // 测试框架\n    { name: \"Jest\", packageName: \"jest\", matchType: 'full', category: \"Testing Frameworks\" },\n    { name: \"Mocha\", packageName: \"mocha\", matchType: 'full', category: \"Testing Frameworks\" },\n    { name: \"Vitest\", packageName: \"vitest\", matchType: 'full', category: \"Testing Frameworks\" },\n\n    // 网络爬虫\n    { name: \"Puppeteer\", packageName: \"puppeteer\", matchType: 'full', category: \"Web Scraping\" },\n    { name: \"Playwright\", packageName: \"playwright\", matchType: 'full', category: \"Web Scraping\" },\n    { name: \"Cheerio\", packageName: \"cheerio\", matchType: 'full', category: \"Web Scraping\" },\n    { name: \"Crawlee\", packageName: \"crawlee\", matchType: 'full', category: \"Web Scraping\" },\n\n    // UI 组件库\n    { name: \"Radix UI\", packageName: \"@radix-ui\", matchType: 'partial', category: \"UI Components\" },\n] as const;\n\nexport const getPopularityTechs = () => popularTechnologies\n\n// 使用类型体操动态生成 PopularTechnologyName 类型\nexport type PopularTechnologyName = typeof popularTechnologies[number]['name'];\n\n// 使用类型体操动态生成 PopularTechnologyPackageName 类型\nexport type PopularTechnologyPackageName = typeof popularTechnologies[number]['packageName'];\n\n// 获取特定类别的技术名称\nexport type TechnologyNameByCategory<C extends PopularityTech['category']> =\n    Extract<PopularTechnologyName,\n        typeof popularTechnologies[number] extends infer T\n        ? T extends PopularityTech & { category: C }\n        ? T['name']\n        : never\n        : never\n    >;\n\n// 类型检查函数\nexport function isPopularTechnology(name: string): name is PopularTechnologyName {\n    return popularTechnologies.some(tech => tech.name === name);\n}"],["/cloudide/workspace/toolbox/packages/github/src/package-checker.ts","// utils/npmVersionChecker.ts\n\nexport interface PackageVersion {\n    version: string;\n    date: string;\n}\n\nexport interface PackageResult {\n    name: string;\n    versions: PackageVersion[];\n    searchRegex: string;\n}\n\nfunction optimizeVersionRegex(versions: string[]): string {\n    const groups: { [key: string]: string[] } = {};\n    versions.forEach(version => {\n        const [major, minor, patch] = version.split('.');\n        const key = `${major}.${minor}`;\n        if (!groups[key]) {\n            groups[key] = [];\n        }\n        groups[key].push(patch);\n    });\n\n    const optimizedGroups = Object.entries(groups).map(([key, patches]) => {\n        const minPatch = Math.min(...patches.map(Number));\n        return `${key}\\\\.(${minPatch}|[1-9]\\\\d*)`;\n    });\n\n    return optimizedGroups.join('|');\n}\n\nfunction createSearchRegex(packageName: string, versions: string[]): string {\n    const versionPattern = optimizeVersionRegex(versions);\n    return `\"${packageName}\"\\\\s*:\\\\s*\"(\\\\^|~)?(${versionPattern})\"`;\n}\n\nfunction extractMajorMinorPatch(version: string): string {\n    const match = version.match(/^(\\d+\\.\\d+\\.\\d+)/);\n    return match ? match[1] : version;\n}\n\nasync function checkPackageVersion(packageName: string, monthsAgo: number = 6, includeLastOutdated: boolean = false): Promise<PackageResult> {\n    try {\n        const response = await fetch(`https://registry.npmjs.org/${packageName}`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json() as {\n            time: { [version: string]: string };\n        }\n\n        const cutoffDate = new Date();\n        cutoffDate.setMonth(cutoffDate.getMonth() - monthsAgo);\n\n        const semverRegex = /^\\d+\\.\\d+\\.\\d+/;\n\n        const sortedVersions = Object.entries(data.time)\n            .filter(([version, _]) => semverRegex.test(version))\n            .sort(([_, a], [__, b]) => new Date(b).getTime() - new Date(a).getTime());\n\n        let recentVersions = sortedVersions\n            .filter(([_, dateString]) => new Date(dateString) > cutoffDate)\n            .map(([version, dateString]) => ({\n                version: extractMajorMinorPatch(version),\n                date: dateString\n            }));\n\n        if (includeLastOutdated && recentVersions.length > 0 && sortedVersions.length > recentVersions.length) {\n            const lastOutdated = sortedVersions[recentVersions.length];\n            recentVersions.push({\n                version: extractMajorMinorPatch(lastOutdated[0]),\n                date: lastOutdated[1]\n            });\n        }\n\n        // Remove duplicates\n        const uniqueVersions = recentVersions.reduce((acc: PackageVersion[], current) => {\n            if (!acc.find(item => item.version === current.version)) {\n                acc.push(current);\n            }\n            return acc;\n        }, []);\n\n        const searchRegex = createSearchRegex(packageName, uniqueVersions.map(v => v.version));\n\n        return {\n            name: packageName,\n            versions: uniqueVersions,\n            searchRegex\n        };\n    } catch (error) {\n        console.error(`Error checking ${packageName}: ${error instanceof Error ? error.message : String(error)}`);\n        return {\n            name: packageName,\n            versions: [],\n            searchRegex: ''\n        };\n    }\n}\n\nexport async function checkNpmPackages(packages: string[], options: {\n    monthsAgo?: number;\n    onlyFirstPackage?: boolean;\n} = {}): Promise<PackageResult[]> {\n    const { monthsAgo = 6, onlyFirstPackage = false } = options;\n\n    if (onlyFirstPackage) {\n        const result = await checkPackageVersion(packages[0], monthsAgo, true);\n        return [result];\n    }\n\n    // 如果有多个包，自动使用并发获取\n    if (packages.length > 1) {\n        return Promise.all(packages.map((pkg, index) =>\n            checkPackageVersion(pkg, index === 0 ? monthsAgo : 6, index === 0)\n        ));\n    } else {\n        // 只有一个包的情况\n        const result = await checkPackageVersion(packages[0], monthsAgo, true);\n        return [result];\n    }\n}\n\nexport function combineRegex(results: PackageResult[]): RegExp[] {\n    return results.filter(result => result.searchRegex).map(result => new RegExp(result.searchRegex));\n}\n"],["/cloudide/workspace/toolbox/packages/github/src/gitHub-oauth-service.ts","import * as http from 'http';\nimport * as https from 'https';\n\n/**\n * Configuration interface for GitHub OAuth service.\n */\nexport interface GitHubOAuthConfig {\n  /**\n   * The client ID provided by GitHub when you registered your OAuth application.\n   * This is a public identifier for your app.\n   * @example \"1234567890abcdef1234\"\n   */\n  clientId: string;\n\n  /**\n   * The client secret provided by GitHub for your OAuth application.\n   * This should be kept confidential and only stored on the server side.\n   * @example \"1234567890abcdef1234567890abcdef12345678\"\n   */\n  clientSecret: string;\n\n  /**\n   * The URI to which GitHub will redirect the user after authorization.\n   * This must exactly match one of the redirect URIs you've registered with GitHub.\n   * @example \"http://localhost:3000/callback\"\n   */\n  redirectUri: string;\n\n  /**\n   * The port number on which the local server will listen for the OAuth callback.\n   * This should match the port in your redirectUri.\n   * @example 3000\n   */\n  port: number;\n}\n\ninterface TokenResponse {\n  access_token?: string;\n  error?: string;\n}\n\nexport class GitHubOAuthService {\n  private config: GitHubOAuthConfig;\n  private server: http.Server;\n\n  constructor(config: GitHubOAuthConfig) {\n    this.config = config;\n    this.server = this.createServer();\n  }\n\n  public start(): Promise<void> {\n    return new Promise((resolve) => {\n      this.server.listen(this.config.port, () => {\n        console.log(`Server running at http://localhost:${this.config.port}`);\n        resolve();\n      });\n    });\n  }\n\n  public stop(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.server.close((err) => {\n        if (err) {\n          reject(err);\n        } else {\n          console.log('Server stopped');\n          resolve();\n        }\n      });\n    });\n  }\n\n  public getToken(): Promise<TokenResponse> {\n    return new Promise((resolve) => {\n      const tokenHandler = (tokenResponse: TokenResponse) => {\n        this.removeAllListeners();\n        resolve(tokenResponse);\n      };\n\n      this.server.once('tokenReceived', tokenHandler);\n    });\n  }\n\n  private createServer(): http.Server {\n    return http.createServer((req, res) => {\n      if (req.url?.startsWith('/callback')) {\n        const urlParams = new URLSearchParams(req.url.split('?')[1]);\n        const code = urlParams.get('code');\n\n        if (code) {\n          this.exchangeCodeForToken(code)\n            .then((tokenData) => {\n              res.writeHead(200, { 'Content-Type': 'text/html' });\n              res.end('<h1>Authorization successful! You can close this window now.</h1>');\n              this.server.emit('tokenReceived', { access_token: tokenData.access_token });\n            })\n            .catch((error) => {\n              res.writeHead(500, { 'Content-Type': 'text/plain' });\n              res.end('Error fetching token');\n              this.server.emit('tokenReceived', { error: error.message });\n            });\n        } else {\n          res.writeHead(400, { 'Content-Type': 'text/plain' });\n          res.end('Missing authorization code');\n          this.server.emit('tokenReceived', { error: 'Missing authorization code' });\n        }\n      } else {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('Not Found');\n      }\n    });\n  }\n\n  private exchangeCodeForToken(code: string): Promise<{ access_token: string }> {\n    return new Promise((resolve, reject) => {\n      const tokenParams = new URLSearchParams({\n        client_id: this.config.clientId,\n        client_secret: this.config.clientSecret,\n        code: code,\n        redirect_uri: this.config.redirectUri,\n      });\n\n      const tokenReq = https.request(\n        {\n          hostname: 'github.com',\n          path: '/login/oauth/access_token',\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Accept': 'application/json',\n          },\n        },\n        (tokenRes) => {\n          let data = '';\n          tokenRes.on('data', (chunk) => {\n            data += chunk;\n          });\n          tokenRes.on('end', () => {\n            const tokenData = JSON.parse(data);\n            if (tokenData.access_token) {\n              resolve(tokenData);\n            } else {\n              reject(new Error('Failed to obtain access token'));\n            }\n          });\n        }\n      );\n\n      tokenReq.on('error', (error) => {\n        reject(error);\n      });\n\n      tokenReq.write(tokenParams.toString());\n      tokenReq.end();\n    });\n  }\n\n  private removeAllListeners(): void {\n    this.server.removeAllListeners('tokenReceived');\n  }\n}\n\n// 使用示例\nexport async function githubOAuthService(config: GitHubOAuthConfig) {\n\n  const service = new GitHubOAuthService(config);\n\n  try {\n    await service.start();\n    console.log('Please authorize the application...');\n\n    const tokenResponse = await service.getToken();\n    if (tokenResponse.access_token) {\n      console.log('Access Token:', tokenResponse.access_token);\n    } else {\n      console.error('Error:', tokenResponse.error);\n    }\n  } catch (error) {\n    console.error('An error occurred:', error);\n  } finally {\n    await service.stop();\n  }\n}\n"],["/cloudide/workspace/toolbox/packages/github/src/github-search-crawler/index.ts","import { crawlGitHub } from './crawler';\nimport { SearchParams } from './types';\nimport { SessionService } from '@devnest/core';\nimport { searchPopularTechnologies } from './popularity-search-service';\n\nasync function main() {\n    const searchParams: SearchParams = {\n        query: \"/next/\",\n        type: 'code',\n        maxPages: 2,\n    };\n    const sessionService = new SessionService();\n    await sessionService.addSession({\n        category: 'github',\n        maxConcurrent: 5,\n        id: 'github-1',\n        authInfo: {\n            \"accept\": \"application/json\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            \"priority\": \"u=1, i\",\n            \"sec-ch-ua\": \"\\\"Not)A;Brand\\\";v=\\\"99\\\", \\\"Google Chrome\\\";v=\\\"127\\\", \\\"Chromium\\\";v=\\\"127\\\"\",\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": \"\\\"Windows\\\"\",\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-origin\",\n            \"x-github-target\": \"dotcom\",\n            \"x-react-router\": \"json\",\n            \"x-requested-with\": \"XMLHttpRequest\",\n            \"cookie\": \"_octo=GH1.1.919065573.1702386987; _device_id=3fab0228c7a1bcb232fa79a2fe311454; saved_user_sessions=33978392%3AW4ra8WefHrzFPqgh4nHIVsYhf6mvOtT-Hd0QniN-_PsLJerU; user_session=W4ra8WefHrzFPqgh4nHIVsYhf6mvOtT-Hd0QniN-_PsLJerU; __Host-user_session_same_site=W4ra8WefHrzFPqgh4nHIVsYhf6mvOtT-Hd0QniN-_PsLJerU; logged_in=yes; dotcom_user=842797524; color_mode=%7B%22color_mode%22%3A%22auto%22%2C%22light_theme%22%3A%7B%22name%22%3A%22light%22%2C%22color_mode%22%3A%22light%22%7D%2C%22dark_theme%22%3A%7B%22name%22%3A%22dark%22%2C%22color_mode%22%3A%22dark%22%7D%7D; preferred_color_mode=light; tz=Asia%2FShanghai; _gh_sess=N94hHAyXEn7Kj8ZmwiCssDF3Wl%2FJODcOy5w3Rs9yXo%2FS1uDsYEGVFPVeRBp6uGxegyzOGZz9l6bEjHlptXjO0%2F0BbosAt11bp%2F1SdnpkE4UYluT%2BwU0133kADS44zXXw63kTxtJ0o7XWlP1Ra1wlTbhfAMUxVm%2BSLH7RBCm%2BQy7EMBpVMLWw5EqotY5NopIw1VMiyWdDmf%2F6sZIVWzfjCqfcTEQzcWbGyBTCdIMwxT6aiaKsOR7TYJvBqtLde7fcuTtQYpdxajEF%2FkzoGsObvrGv65lC5vZyM7tMtQc6jy%2F%2FB%2BFZYEcOMxZPgryedt4G0XcSJGI8essD9SPE3A9yaPZqH8UaUIDIyTTzGPF5AqifqteVnTwIFibqM%2BeSglKA5zJK3dmhPgiSytaheqos%2BshJ6Ggj2T5luzzjEPNcYc89%2FEIwpmqt5UOjfzrby041HrHuj1qBVBz%2F9BPY915di4R1uAmVLtiYoicfPulDliKNmY53gcI7MswQOMUvEGM1n8FHgGLE0CRW4PmwNS4RT6nCv00Uk6gwwJSOFp7ha5yPN90u--pOcWfvvXi0m5KwwZ--1OaYOTMTzqeM8HkK43Uj%2Bw%3D%3D\",\n            \"Referer\": \"https://github.com/search?q=lodash+e&type=repositories\",\n            \"Referrer-Policy\": \"strict-origin-when-cross-origin\"\n        },\n        isDisabled: false,\n        lastUsed: new Date(),\n        usageCount: 0\n    });\n    await sessionService.init();\n     await searchPopularTechnologies({\n        technologies: ['Next.js', \"Tailwind CSS\", \"LangChain\", \"LangGraph\"],\n        monthsAgo: 6,\n        maxPages: 2\n    }, sessionService)\n\n    // try {\n    //     const result = await crawlGitHub(searchParams, sessionService);\n\n    //     console.log(`Repositories crawled: ${result.repositories.length}`);\n    //     console.log('First 5 repositories:');\n    //     result.repositories.slice(0, 5).forEach((repo, index) => {\n    //         console.log(`\\n${index + 1}. ${repo.id}`);\n\n    //     });\n    // } catch (error) {\n    //     console.error('An error occurred:', error);\n    // }\n}\n\nmain();"],["/cloudide/workspace/toolbox/packages/github/src/github-search-crawler/crawler.ts","import { SearchParams, CrawlerResult, } from './types';\nimport { SessionService } from '@devnest/core';\nimport { HttpCrawler, HttpCrawlingContext } from 'crawlee';\n\nexport async function crawlGitHub(params: SearchParams, sessionService?: SessionService): Promise<CrawlerResult> {\n    const { query, type, maxPages } = params;\n\n    const result: CrawlerResult = { repositories: [], };\n\n    const crawler = new HttpCrawler({\n        maxConcurrency: 5,\n        async requestHandler({ request, json }: HttpCrawlingContext) {\n            const getFullName = repo => repo.repo_nwo || repo.hl_name.replace(/&#x2F;/g, '/').replace(/<em>|<\\/em>/g, '')\n            const repositories = json.payload.results.map(repo => ({ id: repo.id || repo.repo_id, fullName: getFullName(repo) }));\n            result.repositories.push(...repositories);\n\n            // Enqueue next pages\n            if (request.userData.page === 1) {\n                const baseUrl = request.url.split('&p=')[0];\n                const requests: any = [];\n\n                for (let p = 2; p <= Math.min(maxPages, json.payload.page_count); p++) {\n                    requests.push({\n                        url: `${baseUrl}&p=${p}`,\n                        userData: { ...request.userData, page: p }\n                    });\n                }\n\n                await crawler.addRequests(requests);\n            }\n        },\n        preNavigationHooks: [\n            async ({ request, }) => {\n                const session = await sessionService?.acquireSession(\"github\");\n                if (session) {\n                    Object.assign(request.headers as object, session.authInfo);\n                    request.userData.session = session;\n                }\n            }\n        ],\n        postNavigationHooks: [\n            async ({ request }) => {\n                const session = request.userData.session;\n                if (session) {\n                    await sessionService?.releaseSession(session.id);\n                }\n            }\n        ],\n    });\n\n    const baseUrl = 'https://github.com/search';\n    const searchParams = new URLSearchParams({\n        q: query,\n        type,\n        p: '1',\n    });\n\n    await crawler.addRequests([{\n        url: `${baseUrl}?${searchParams.toString()}`,\n        userData: { page: 1 },\n        label: 'pagination',\n    }]);\n\n    await crawler.run();\n\n    return result;\n}\n"],["/cloudide/workspace/toolbox/packages/github/src/github-search-crawler/types.ts","export interface SearchParams {\n    query: string;\n    type: 'repositories' | 'code';\n    maxPages: number;\n}\n\nexport interface RepositoryData {\n    id: number;\n    // name: string;\n    // fullName: string;\n    // url: string;\n    // description: string;\n    // stars: number;\n    // language: string;\n    // updatedAt: string;\n}\n\nexport interface CrawlerResult {\n    repositories: RepositoryData[];\n}\n\n// 新增：用于解析 JSON 数据的接口\nexport interface GitHubSearchData {\n    payload: {\n        results: Array<{\n            id: number;\n            repo_id: number;\n            name: string;\n            fullName: string;\n            url: string;\n            description: string;\n            stargazerCount: number;\n            primaryLanguage: {\n                name: string;\n            } | null;\n            updatedAt: string;\n        }>\n    };\n}"],["/cloudide/workspace/toolbox/packages/core/dist/index.d.ts","interface Session {\n    id: string;\n    authInfo: {\n        cookies?: string;\n        token?: string;\n        [key: string]: any;\n    };\n    isDisabled: boolean;\n    lastUsed: Date;\n    usageCount: number;\n    nextAvailableTime?: Date;\n    category: string;\n    maxConcurrent: number;\n    currentConcurrent: number;\n}\ninterface PersistenceProvider {\n    save(sessions: Map<string, Session>): Promise<void>;\n    load(): Promise<Map<string, Session>>;\n}\n\ndeclare class SessionService {\n    private sessions;\n    private persistenceProvider;\n    private waitingQueue;\n    constructor(persistenceProvider?: PersistenceProvider);\n    init(): Promise<void>;\n    private save;\n    getSession(sessionId: string): Session | undefined;\n    disableSession(sessionId: string): Promise<boolean>;\n    setSessionNextAvailableTime(sessionId: string, nextAvailableTime: Date): Promise<boolean>;\n    resetSessionUsage(sessionId: string): Promise<boolean>;\n    updateAuthInfo(sessionId: string, authInfo: Partial<Session['authInfo']>): Promise<boolean>;\n    addSession(session: Partial<Session>): Promise<void>;\n    acquireSession(category?: string, maxWaitTime?: number): Promise<Session | null>;\n    releaseSession(sessionId: string): Promise<void>;\n    private selectNextSession;\n    private addToWaitingQueue;\n    private removeFromWaitingQueue;\n}\n\nexport { type PersistenceProvider, type Session, SessionService };\n"],["/cloudide/workspace/toolbox/packages/github/src/github-search-crawler/popularity-search-service.ts","import { getPopularityTechs, PopularTechnologyName, PopularTechnologyPackageName } from '../popularity';\nimport { SearchParams, RepositoryData } from './types';\nimport { crawlGitHub } from './crawler';\nimport { SessionService } from '@devnest/core';\nimport { checkNpmPackages, PackageResult, combineRegex } from '../package-checker';\n\n/**\n * Options for the popularity search service\n */\ninterface PopularitySearchOptions {\n    technologies: PopularTechnologyName[];\n    monthsAgo?: number;\n    maxPages?: number;\n    onlyFirstPackage?: boolean;\n}\n\n/**\n * Result of the popularity search service\n */\ninterface PopularitySearchResult {\n    repositories: RepositoryData[];\n    packageVersions: PackageResult[];\n}\n\n/**\n * Searches for repositories using popular technologies\n * @param options - Search options including technologies, months ago for version check, and max pages to crawl\n * @param sessionService - Session service for authentication\n * @returns Promise resolving to PopularitySearchResult\n */\nexport async function searchPopularTechnologies(\n    options: PopularitySearchOptions,\n    sessionService: SessionService\n): Promise<PopularitySearchResult> {\n    const { technologies, monthsAgo = 6, maxPages = 5, onlyFirstPackage = true } = options;\n    const { packageNames, packageVersions } = await getPackageInfo(technologies, { monthsAgo, onlyFirstPackage })\n    const regexPatterns = combineRegex(packageVersions);\n\n    // 4. Create search query using the combined regex\n    const searchQuery = (onlyFirstPackage ? packageNames.slice(1).join(\" \") + \" \" : \"\") + regexPatterns.map(regex => `/${regex.source}/`).join(' ') + ' -is:fork';\n    console.log(\"searchQuery\", searchQuery);\n\n    const searchParams: SearchParams = {\n        query: searchQuery,\n        type: 'code',\n        maxPages: maxPages\n    };\n\n    // 6. Perform the GitHub search\n    const searchResults = await crawlGitHub(searchParams, sessionService);\n\n    // 7. Return the combined results\n    return {\n        repositories: searchResults.repositories,\n        packageVersions\n    };\n}\n\n/**\n * Retrieves package information for specified technologies\n * @param technologies - Array of technology names to fetch package info for\n * @param monthsAgo - Number of months to look back for package versions\n * @returns Promise resolving to an array of PackageResult\n */\nasync function getPackageInfo(\n    technologies: PopularTechnologyName[],\n    options: {\n        monthsAgo?: number;\n        onlyFirstPackage?: boolean;\n    } = {}\n): Promise<{ packageVersions: PackageResult[], packageNames: PopularTechnologyPackageName[] }> {\n    const allTechs = getPopularityTechs();\n    const selectedTechs = allTechs.filter(tech => technologies.includes(tech.name as PopularTechnologyName));\n    const packageNames = selectedTechs.map(tech => tech.packageName);\n\n    return {\n        packageVersions: await checkNpmPackages(packageNames, options),\n        packageNames\n    };\n}\n"]],"moduleName":"github","componentType":"module"}