{"moduleName":"github","entryFile":"index.ts","dependencies":{"local":[{"original":"./popularity","resolved":"popularity.ts","content":"// 热门技术仓库搜索\ntype MatchType = 'full' | 'partial'\n\nexport interface PopularityTech {\n    name: string;\n    packageName: string;\n    matchType: MatchType;\n    category: string;\n}\n\nconst popularTechnologies = [\n    // 前端框架和库\n    { name: \"React\", packageName: \"react\", matchType: 'full', category: \"Frontend Frameworks\" },\n    { name: \"Vue.js\", packageName: \"vue\", matchType: 'full', category: \"Frontend Frameworks\" },\n    { name: \"Svelte\", packageName: \"svelte\", matchType: 'full', category: \"Frontend Frameworks\" },\n    { name: \"Angular\", packageName: \"angular\", matchType: 'full', category: \"Frontend Frameworks\" },\n\n    // 全栈和服务端渲染框架\n    { name: \"Next.js\", packageName: \"next\", matchType: 'full', category: \"Fullstack Frameworks\" },\n    { name: \"Nuxt.js\", packageName: \"nuxt\", matchType: 'full', category: \"Fullstack Frameworks\" },\n    { name: \"Remix\", packageName: \"remix\", matchType: 'full', category: \"Fullstack Frameworks\" },\n    { name: \"SvelteKit\", packageName: \"@sveltejs/kit\", matchType: 'full', category: \"Fullstack Frameworks\" },\n    { name: \"Blitz.js\", packageName: \"blitz\", matchType: 'full', category: \"Fullstack Frameworks\" },\n    { name: \"Astro\", packageName: \"astro\", matchType: 'full', category: \"Fullstack Frameworks\" },\n\n    // 后端框架\n    { name: \"NestJS\", packageName: \"@nestjs/core\", matchType: 'full', category: \"Backend Frameworks\" },\n    { name: \"Express.js\", packageName: \"express\", matchType: 'full', category: \"Backend Frameworks\" },\n    { name: \"Fastify\", packageName: \"fastify\", matchType: 'full', category: \"Backend Frameworks\" },\n\n    // 云服务和部署平台\n    { name: \"Vercel\", packageName: \"@vercel/node\", matchType: 'full', category: \"Cloud Services\" },\n    { name: \"Netlify\", packageName: \"netlify-cli\", matchType: 'full', category: \"Cloud Services\" },\n    { name: \"Cloudflare Workers\", packageName: \"@cloudflare/workers-types\", matchType: 'full', category: \"Cloud Services\" },\n    { name: \"AWS SDK\", packageName: \"aws-sdk\", matchType: 'full', category: \"Cloud Services\" },\n    { name: \"Google Cloud Storage\", packageName: \"@google-cloud/storage\", matchType: 'full', category: \"Cloud Services\" },\n    { name: \"Azure Blob Storage\", packageName: \"@azure/storage-blob\", matchType: 'full', category: \"Cloud Services\" },\n\n    // CSS 框架和工具\n    { name: \"Tailwind CSS\", packageName: \"tailwindcss\", matchType: 'full', category: \"CSS Frameworks\" },\n    { name: \"styled-components\", packageName: \"styled-components\", matchType: 'full', category: \"CSS Frameworks\" },\n    { name: \"Sass\", packageName: \"sass\", matchType: 'full', category: \"CSS Frameworks\" },\n    { name: \"Less\", packageName: \"less\", matchType: 'full', category: \"CSS Frameworks\" },\n\n    // 状态管理\n    { name: \"Redux\", packageName: \"redux\", matchType: 'full', category: \"State Management\" },\n    { name: \"MobX\", packageName: \"mobx\", matchType: 'full', category: \"State Management\" },\n    { name: \"Recoil\", packageName: \"recoil\", matchType: 'full', category: \"State Management\" },\n    { name: \"Zustand\", packageName: \"zustand\", matchType: 'full', category: \"State Management\" },\n    { name: \"Pinia\", packageName: \"pinia\", matchType: 'full', category: \"State Management\" },\n\n    // 认证和授权\n    { name: \"NextAuth.js\", packageName: \"next-auth\", matchType: 'full', category: \"Authentication & Authorization\" },\n    { name: \"Firebase\", packageName: \"firebase\", matchType: 'full', category: \"Authentication & Authorization\" },\n    { name: \"Auth0\", packageName: \"@auth0/auth0-react\", matchType: 'full', category: \"Authentication & Authorization\" },\n    { name: \"Passport.js\", packageName: \"passport\", matchType: 'full', category: \"Authentication & Authorization\" },\n    { name: \"Clerk\", packageName: \"@clerk/clerk-react\", matchType: 'full', category: \"Authentication & Authorization\" },\n\n    // API 开发和管理\n    { name: \"GraphQL\", packageName: \"graphql\", matchType: 'full', category: \"API Technologies\" },\n    { name: \"Apollo Client\", packageName: \"@apollo/client\", matchType: 'full', category: \"API Technologies\" },\n    { name: \"Swagger UI Express\", packageName: \"swagger-ui-express\", matchType: 'full', category: \"API Technologies\" },\n    { name: \"tRPC\", packageName: \"@trpc/server\", matchType: 'full', category: \"API Technologies\" },\n\n    // 数据库和ORM\n    { name: \"Prisma\", packageName: \"@prisma/client\", matchType: 'full', category: \"Database & ORM\" },\n    { name: \"TypeORM\", packageName: \"typeorm\", matchType: 'full', category: \"Database & ORM\" },\n    { name: \"Mongoose\", packageName: \"mongoose\", matchType: 'full', category: \"Database & ORM\" },\n    { name: \"Sequelize\", packageName: \"sequelize\", matchType: 'full', category: \"Database & ORM\" },\n\n    // AI 和机器学习\n    { name: \"TensorFlow.js\", packageName: \"@tensorflow/tfjs\", matchType: 'full', category: \"AI & ML\" },\n    { name: \"OpenAI\", packageName: \"openai\", matchType: 'full', category: \"AI & ML\" },\n    { name: \"Anthropic\", packageName: \"@anthropic-ai/sdk\", matchType: 'full', category: \"AI & ML\" },\n    { name: \"Hugging Face\", packageName: \"@huggingface/inference\", matchType: 'full', category: \"AI & ML\" },\n    { name: \"LangChain\", packageName: \"@langchain/core\", matchType: 'full', category: \"AI & ML\" },\n    { name: \"LangGraph\", packageName: \"@langchain/langgraph\", matchType: 'full', category: \"AI & ML\" },\n\n    // 构建工具\n    { name: \"Webpack\", packageName: \"webpack\", matchType: 'full', category: \"Build Tools\" },\n    { name: \"Vite\", packageName: \"vite\", matchType: 'full', category: \"Build Tools\" },\n\n    // 开发工具\n    { name: \"TypeScript\", packageName: \"typescript\", matchType: 'full', category: \"Developer Tools\" },\n    { name: \"ESLint\", packageName: \"eslint\", matchType: 'full', category: \"Developer Tools\" },\n    { name: \"Prettier\", packageName: \"prettier\", matchType: 'full', category: \"Developer Tools\" },\n\n    // 测试框架\n    { name: \"Jest\", packageName: \"jest\", matchType: 'full', category: \"Testing Frameworks\" },\n    { name: \"Mocha\", packageName: \"mocha\", matchType: 'full', category: \"Testing Frameworks\" },\n    { name: \"Vitest\", packageName: \"vitest\", matchType: 'full', category: \"Testing Frameworks\" },\n\n    // 网络爬虫\n    { name: \"Puppeteer\", packageName: \"puppeteer\", matchType: 'full', category: \"Web Scraping\" },\n    { name: \"Playwright\", packageName: \"playwright\", matchType: 'full', category: \"Web Scraping\" },\n    { name: \"Cheerio\", packageName: \"cheerio\", matchType: 'full', category: \"Web Scraping\" },\n    { name: \"Crawlee\", packageName: \"crawlee\", matchType: 'full', category: \"Web Scraping\" },\n\n    // UI 组件库\n    { name: \"Radix UI\", packageName: \"@radix-ui\", matchType: 'partial', category: \"UI Components\" },\n] as const;\n\nexport const getPopularityTechs = () => popularTechnologies\n\n// 使用类型体操动态生成 PopularTechnologyName 类型\nexport type PopularTechnologyName = typeof popularTechnologies[number]['name'];\n\n// 使用类型体操动态生成 PopularTechnologyPackageName 类型\nexport type PopularTechnologyPackageName = typeof popularTechnologies[number]['packageName'];\n\n// 获取特定类别的技术名称\nexport type TechnologyNameByCategory<C extends PopularityTech['category']> =\n    Extract<PopularTechnologyName,\n        typeof popularTechnologies[number] extends infer T\n        ? T extends PopularityTech & { category: C }\n        ? T['name']\n        : never\n        : never\n    >;\n\n// 类型检查函数\nexport function isPopularTechnology(name: string): name is PopularTechnologyName {\n    return popularTechnologies.some(tech => tech.name === name);\n}","dependencies":{"local":[],"thirdParty":[],"dynamic":[],"require":[],"core":[]},"isDynamic":false,"importType":"import"},{"original":"./package-checker","resolved":"package-checker.ts","content":"// utils/npmVersionChecker.ts\n\nexport interface PackageVersion {\n    version: string;\n    date: string;\n}\n\nexport interface PackageResult {\n    name: string;\n    versions: PackageVersion[];\n    searchRegex: string;\n}\n\nfunction optimizeVersionRegex(versions: string[]): string {\n    const groups: { [key: string]: string[] } = {};\n    versions.forEach(version => {\n        const [major, minor, patch] = version.split('.');\n        const key = `${major}.${minor}`;\n        if (!groups[key]) {\n            groups[key] = [];\n        }\n        groups[key].push(patch);\n    });\n\n    const optimizedGroups = Object.entries(groups).map(([key, patches]) => {\n        const minPatch = Math.min(...patches.map(Number));\n        return `${key}\\\\.(${minPatch}|[1-9]\\\\d*)`;\n    });\n\n    return optimizedGroups.join('|');\n}\n\nfunction createSearchRegex(packageName: string, versions: string[]): string {\n    const versionPattern = optimizeVersionRegex(versions);\n    return `\"${packageName}\"\\\\s*:\\\\s*\"(\\\\^|~)?(${versionPattern})\"`;\n}\n\nfunction extractMajorMinorPatch(version: string): string {\n    const match = version.match(/^(\\d+\\.\\d+\\.\\d+)/);\n    return match ? match[1] : version;\n}\n\nasync function checkPackageVersion(packageName: string, monthsAgo: number = 6, includeLastOutdated: boolean = false): Promise<PackageResult> {\n    try {\n        const response = await fetch(`https://registry.npmjs.org/${packageName}`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json() as {\n            time: { [version: string]: string };\n        }\n\n        const cutoffDate = new Date();\n        cutoffDate.setMonth(cutoffDate.getMonth() - monthsAgo);\n\n        const semverRegex = /^\\d+\\.\\d+\\.\\d+/;\n\n        const sortedVersions = Object.entries(data.time)\n            .filter(([version, _]) => semverRegex.test(version))\n            .sort(([_, a], [__, b]) => new Date(b).getTime() - new Date(a).getTime());\n\n        let recentVersions = sortedVersions\n            .filter(([_, dateString]) => new Date(dateString) > cutoffDate)\n            .map(([version, dateString]) => ({\n                version: extractMajorMinorPatch(version),\n                date: dateString\n            }));\n\n        if (includeLastOutdated && recentVersions.length > 0 && sortedVersions.length > recentVersions.length) {\n            const lastOutdated = sortedVersions[recentVersions.length];\n            recentVersions.push({\n                version: extractMajorMinorPatch(lastOutdated[0]),\n                date: lastOutdated[1]\n            });\n        }\n\n        // Remove duplicates\n        const uniqueVersions = recentVersions.reduce((acc: PackageVersion[], current) => {\n            if (!acc.find(item => item.version === current.version)) {\n                acc.push(current);\n            }\n            return acc;\n        }, []);\n\n        const searchRegex = createSearchRegex(packageName, uniqueVersions.map(v => v.version));\n\n        return {\n            name: packageName,\n            versions: uniqueVersions,\n            searchRegex\n        };\n    } catch (error) {\n        console.error(`Error checking ${packageName}: ${error instanceof Error ? error.message : String(error)}`);\n        return {\n            name: packageName,\n            versions: [],\n            searchRegex: ''\n        };\n    }\n}\n\nexport async function checkNpmPackages(packages: string[], options: {\n    monthsAgo?: number;\n    onlyFirstPackage?: boolean;\n} = {}): Promise<PackageResult[]> {\n    const { monthsAgo = 6, onlyFirstPackage = false } = options;\n\n    if (onlyFirstPackage) {\n        const result = await checkPackageVersion(packages[0], monthsAgo, true);\n        return [result];\n    }\n\n    // 如果有多个包，自动使用并发获取\n    if (packages.length > 1) {\n        return Promise.all(packages.map((pkg, index) =>\n            checkPackageVersion(pkg, index === 0 ? monthsAgo : 6, index === 0)\n        ));\n    } else {\n        // 只有一个包的情况\n        const result = await checkPackageVersion(packages[0], monthsAgo, true);\n        return [result];\n    }\n}\n\nexport function combineRegex(results: PackageResult[]): RegExp[] {\n    return results.filter(result => result.searchRegex).map(result => new RegExp(result.searchRegex));\n}\n","dependencies":{"local":[],"thirdParty":[],"dynamic":[],"require":[],"core":[]},"isDynamic":false,"importType":"import"},{"original":"./gitHub-oauth-service","resolved":"gitHub-oauth-service.ts","content":"import * as http from 'http';\nimport * as https from 'https';\n\n/**\n * Configuration interface for GitHub OAuth service.\n */\nexport interface GitHubOAuthConfig {\n  /**\n   * The client ID provided by GitHub when you registered your OAuth application.\n   * This is a public identifier for your app.\n   * @example \"1234567890abcdef1234\"\n   */\n  clientId: string;\n\n  /**\n   * The client secret provided by GitHub for your OAuth application.\n   * This should be kept confidential and only stored on the server side.\n   * @example \"1234567890abcdef1234567890abcdef12345678\"\n   */\n  clientSecret: string;\n\n  /**\n   * The URI to which GitHub will redirect the user after authorization.\n   * This must exactly match one of the redirect URIs you've registered with GitHub.\n   * @example \"http://localhost:3000/callback\"\n   */\n  redirectUri: string;\n\n  /**\n   * The port number on which the local server will listen for the OAuth callback.\n   * This should match the port in your redirectUri.\n   * @example 3000\n   */\n  port: number;\n}\n\ninterface TokenResponse {\n  access_token?: string;\n  error?: string;\n}\n\nexport class GitHubOAuthService {\n  private config: GitHubOAuthConfig;\n  private server: http.Server;\n\n  constructor(config: GitHubOAuthConfig) {\n    this.config = config;\n    this.server = this.createServer();\n  }\n\n  public start(): Promise<void> {\n    return new Promise((resolve) => {\n      this.server.listen(this.config.port, () => {\n        console.log(`Server running at http://localhost:${this.config.port}`);\n        resolve();\n      });\n    });\n  }\n\n  public stop(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.server.close((err) => {\n        if (err) {\n          reject(err);\n        } else {\n          console.log('Server stopped');\n          resolve();\n        }\n      });\n    });\n  }\n\n  public getToken(): Promise<TokenResponse> {\n    return new Promise((resolve) => {\n      const tokenHandler = (tokenResponse: TokenResponse) => {\n        this.removeAllListeners();\n        resolve(tokenResponse);\n      };\n\n      this.server.once('tokenReceived', tokenHandler);\n    });\n  }\n\n  private createServer(): http.Server {\n    return http.createServer((req, res) => {\n      if (req.url?.startsWith('/callback')) {\n        const urlParams = new URLSearchParams(req.url.split('?')[1]);\n        const code = urlParams.get('code');\n\n        if (code) {\n          this.exchangeCodeForToken(code)\n            .then((tokenData) => {\n              res.writeHead(200, { 'Content-Type': 'text/html' });\n              res.end('<h1>Authorization successful! You can close this window now.</h1>');\n              this.server.emit('tokenReceived', { access_token: tokenData.access_token });\n            })\n            .catch((error) => {\n              res.writeHead(500, { 'Content-Type': 'text/plain' });\n              res.end('Error fetching token');\n              this.server.emit('tokenReceived', { error: error.message });\n            });\n        } else {\n          res.writeHead(400, { 'Content-Type': 'text/plain' });\n          res.end('Missing authorization code');\n          this.server.emit('tokenReceived', { error: 'Missing authorization code' });\n        }\n      } else {\n        res.writeHead(404, { 'Content-Type': 'text/plain' });\n        res.end('Not Found');\n      }\n    });\n  }\n\n  private exchangeCodeForToken(code: string): Promise<{ access_token: string }> {\n    return new Promise((resolve, reject) => {\n      const tokenParams = new URLSearchParams({\n        client_id: this.config.clientId,\n        client_secret: this.config.clientSecret,\n        code: code,\n        redirect_uri: this.config.redirectUri,\n      });\n\n      const tokenReq = https.request(\n        {\n          hostname: 'github.com',\n          path: '/login/oauth/access_token',\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'Accept': 'application/json',\n          },\n        },\n        (tokenRes) => {\n          let data = '';\n          tokenRes.on('data', (chunk) => {\n            data += chunk;\n          });\n          tokenRes.on('end', () => {\n            const tokenData = JSON.parse(data);\n            if (tokenData.access_token) {\n              resolve(tokenData);\n            } else {\n              reject(new Error('Failed to obtain access token'));\n            }\n          });\n        }\n      );\n\n      tokenReq.on('error', (error) => {\n        reject(error);\n      });\n\n      tokenReq.write(tokenParams.toString());\n      tokenReq.end();\n    });\n  }\n\n  private removeAllListeners(): void {\n    this.server.removeAllListeners('tokenReceived');\n  }\n}\n\n// 使用示例\nexport async function githubOAuthService(config: GitHubOAuthConfig) {\n\n  const service = new GitHubOAuthService(config);\n\n  try {\n    await service.start();\n    console.log('Please authorize the application...');\n\n    const tokenResponse = await service.getToken();\n    if (tokenResponse.access_token) {\n      console.log('Access Token:', tokenResponse.access_token);\n    } else {\n      console.error('Error:', tokenResponse.error);\n    }\n  } catch (error) {\n    console.error('An error occurred:', error);\n  } finally {\n    await service.stop();\n  }\n}\n","dependencies":{"local":[],"thirdParty":[],"dynamic":[],"require":[],"core":["http","https"]},"isDynamic":false,"importType":"import"},{"original":"./github-search-crawler","resolved":"github-search-crawler/index.ts","content":"import { crawlGitHub } from './crawler';\nimport { SearchParams } from './types';\nimport { SessionService } from '@devnest/core';\nimport { searchPopularTechnologies } from './popularity-search-service';\n\nasync function main() {\n    const searchParams: SearchParams = {\n        query: \"/next/\",\n        type: 'code',\n        maxPages: 2,\n    };\n    const sessionService = new SessionService();\n    await sessionService.addSession({\n        category: 'github',\n        maxConcurrent: 5,\n        id: 'github-1',\n        authInfo: {\n            \"accept\": \"application/json\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            \"priority\": \"u=1, i\",\n            \"sec-ch-ua\": \"\\\"Not)A;Brand\\\";v=\\\"99\\\", \\\"Google Chrome\\\";v=\\\"127\\\", \\\"Chromium\\\";v=\\\"127\\\"\",\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": \"\\\"Windows\\\"\",\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-origin\",\n            \"x-github-target\": \"dotcom\",\n            \"x-react-router\": \"json\",\n            \"x-requested-with\": \"XMLHttpRequest\",\n            \"cookie\": \"_octo=GH1.1.919065573.1702386987; _device_id=3fab0228c7a1bcb232fa79a2fe311454; saved_user_sessions=33978392%3AW4ra8WefHrzFPqgh4nHIVsYhf6mvOtT-Hd0QniN-_PsLJerU; user_session=W4ra8WefHrzFPqgh4nHIVsYhf6mvOtT-Hd0QniN-_PsLJerU; __Host-user_session_same_site=W4ra8WefHrzFPqgh4nHIVsYhf6mvOtT-Hd0QniN-_PsLJerU; logged_in=yes; dotcom_user=842797524; color_mode=%7B%22color_mode%22%3A%22auto%22%2C%22light_theme%22%3A%7B%22name%22%3A%22light%22%2C%22color_mode%22%3A%22light%22%7D%2C%22dark_theme%22%3A%7B%22name%22%3A%22dark%22%2C%22color_mode%22%3A%22dark%22%7D%7D; preferred_color_mode=light; tz=Asia%2FShanghai; _gh_sess=N94hHAyXEn7Kj8ZmwiCssDF3Wl%2FJODcOy5w3Rs9yXo%2FS1uDsYEGVFPVeRBp6uGxegyzOGZz9l6bEjHlptXjO0%2F0BbosAt11bp%2F1SdnpkE4UYluT%2BwU0133kADS44zXXw63kTxtJ0o7XWlP1Ra1wlTbhfAMUxVm%2BSLH7RBCm%2BQy7EMBpVMLWw5EqotY5NopIw1VMiyWdDmf%2F6sZIVWzfjCqfcTEQzcWbGyBTCdIMwxT6aiaKsOR7TYJvBqtLde7fcuTtQYpdxajEF%2FkzoGsObvrGv65lC5vZyM7tMtQc6jy%2F%2FB%2BFZYEcOMxZPgryedt4G0XcSJGI8essD9SPE3A9yaPZqH8UaUIDIyTTzGPF5AqifqteVnTwIFibqM%2BeSglKA5zJK3dmhPgiSytaheqos%2BshJ6Ggj2T5luzzjEPNcYc89%2FEIwpmqt5UOjfzrby041HrHuj1qBVBz%2F9BPY915di4R1uAmVLtiYoicfPulDliKNmY53gcI7MswQOMUvEGM1n8FHgGLE0CRW4PmwNS4RT6nCv00Uk6gwwJSOFp7ha5yPN90u--pOcWfvvXi0m5KwwZ--1OaYOTMTzqeM8HkK43Uj%2Bw%3D%3D\",\n            \"Referer\": \"https://github.com/search?q=lodash+e&type=repositories\",\n            \"Referrer-Policy\": \"strict-origin-when-cross-origin\"\n        },\n        isDisabled: false,\n        lastUsed: new Date(),\n        usageCount: 0\n    });\n    await sessionService.init();\n     await searchPopularTechnologies({\n        technologies: ['Next.js', \"Tailwind CSS\", \"LangChain\", \"LangGraph\"],\n        monthsAgo: 6,\n        maxPages: 2\n    }, sessionService)\n\n    // try {\n    //     const result = await crawlGitHub(searchParams, sessionService);\n\n    //     console.log(`Repositories crawled: ${result.repositories.length}`);\n    //     console.log('First 5 repositories:');\n    //     result.repositories.slice(0, 5).forEach((repo, index) => {\n    //         console.log(`\\n${index + 1}. ${repo.id}`);\n\n    //     });\n    // } catch (error) {\n    //     console.error('An error occurred:', error);\n    // }\n}\n\nmain();","dependencies":{"local":[{"original":"./crawler","resolved":"github-search-crawler/crawler.ts","content":"import { HttpCrawler, HttpCrawlingContext } from 'crawlee';\nimport { SearchParams, CrawlerResult, } from './types';\nimport { SessionService } from '@devnest/core';\n\nexport async function crawlGitHub(params: SearchParams, sessionService?: SessionService): Promise<CrawlerResult> {\n    const { query, type, maxPages } = params;\n\n    const result: CrawlerResult = { repositories: [], };\n\n    const crawler = new HttpCrawler({\n        maxConcurrency: 5,\n        async requestHandler({ request, json }: HttpCrawlingContext) {\n            const getFullName = repo => repo.repo_nwo || repo.hl_name.replace(/&#x2F;/g, '/').replace(/<em>|<\\/em>/g, '')\n            const repositories = json.payload.results.map(repo => ({ id: repo.id || repo.repo_id, fullName: getFullName(repo) }));\n            result.repositories.push(...repositories);\n\n            // Enqueue next pages\n            if (request.userData.page === 1) {\n                const baseUrl = request.url.split('&p=')[0];\n                const requests: any = [];\n\n                for (let p = 2; p <= Math.min(maxPages, json.payload.page_count); p++) {\n                    requests.push({\n                        url: `${baseUrl}&p=${p}`,\n                        userData: { ...request.userData, page: p }\n                    });\n                }\n\n                await crawler.addRequests(requests);\n            }\n        },\n        preNavigationHooks: [\n            async ({ request, }) => {\n                const session = await sessionService?.acquireSession(\"github\");\n                if (session) {\n                    Object.assign(request.headers as object, session.authInfo);\n                    request.userData.session = session;\n                }\n            }\n        ],\n        postNavigationHooks: [\n            async ({ request }) => {\n                const session = request.userData.session;\n                if (session) {\n                    await sessionService?.releaseSession(session.id);\n                }\n            }\n        ],\n    });\n\n    const baseUrl = 'https://github.com/search';\n    const searchParams = new URLSearchParams({\n        q: query,\n        type,\n        p: '1',\n    });\n\n    await crawler.addRequests([{\n        url: `${baseUrl}?${searchParams.toString()}`,\n        userData: { page: 1 },\n        label: 'pagination',\n    }]);\n\n    await crawler.run();\n\n    return result;\n}\n","dependencies":{"local":[{"original":"./types","resolved":"github-search-crawler/types.ts","content":"export interface SearchParams {\n    query: string;\n    type: 'repositories' | 'code';\n    maxPages: number;\n}\n\nexport interface RepositoryData {\n    id: number;\n    // name: string;\n    // fullName: string;\n    // url: string;\n    // description: string;\n    // stars: number;\n    // language: string;\n    // updatedAt: string;\n}\n\nexport interface CrawlerResult {\n    repositories: RepositoryData[];\n}\n\n// 新增：用于解析 JSON 数据的接口\nexport interface GitHubSearchData {\n    payload: {\n        results: Array<{\n            id: number;\n            repo_id: number;\n            name: string;\n            fullName: string;\n            url: string;\n            description: string;\n            stargazerCount: number;\n            primaryLanguage: {\n                name: string;\n            } | null;\n            updatedAt: string;\n        }>\n    };\n}","dependencies":{"local":[],"thirdParty":[],"dynamic":[],"require":[],"core":[]},"isDynamic":false,"importType":"import"},{"original":"@devnest/core","resolved":"../../core/dist/index.js","content":"'use strict';\n\nvar fs = require('fs/promises');\nvar path = require('path');\n\nclass LocalPersistence {\n    filePath;\n    constructor(filePath = path.join(process.cwd(), 'sessions.json')) {\n        this.filePath = filePath;\n    }\n    async save(sessions) {\n        const serialized = JSON.stringify(Array.from(sessions.entries()), null, 2);\n        await fs.writeFile(this.filePath, serialized, 'utf-8');\n    }\n    async load() {\n        try {\n            const data = await fs.readFile(this.filePath, 'utf-8');\n            const entries = JSON.parse(data);\n            return new Map(entries.map(([id, session]) => [\n                id,\n                {\n                    ...session,\n                    lastUsed: new Date(session.lastUsed),\n                    nextAvailableTime: session.nextAvailableTime ? new Date(session.nextAvailableTime) : undefined\n                }\n            ]));\n        }\n        catch (error) {\n            if (error.code === 'ENOENT') {\n                return new Map();\n            }\n            throw error;\n        }\n    }\n}\n\nclass SessionService {\n    sessions = new Map();\n    persistenceProvider;\n    waitingQueue = new Map();\n    constructor(persistenceProvider) {\n        this.persistenceProvider = persistenceProvider || new LocalPersistence();\n    }\n    async init() {\n        this.sessions = await this.persistenceProvider.load();\n    }\n    async save() {\n        await this.persistenceProvider.save(this.sessions);\n    }\n    getSession(sessionId) {\n        return this.sessions.get(sessionId);\n    }\n    async disableSession(sessionId) {\n        const session = this.sessions.get(sessionId);\n        if (session) {\n            session.isDisabled = true;\n            await this.save();\n            return true;\n        }\n        return false;\n    }\n    async setSessionNextAvailableTime(sessionId, nextAvailableTime) {\n        const session = this.sessions.get(sessionId);\n        if (session) {\n            session.nextAvailableTime = nextAvailableTime;\n            await this.save();\n            return true;\n        }\n        return false;\n    }\n    async resetSessionUsage(sessionId) {\n        const session = this.sessions.get(sessionId);\n        if (session) {\n            session.usageCount = 0;\n            session.nextAvailableTime = undefined;\n            session.isDisabled = false;\n            await this.save();\n            return true;\n        }\n        return false;\n    }\n    async updateAuthInfo(sessionId, authInfo) {\n        const session = this.sessions.get(sessionId);\n        if (session) {\n            session.authInfo = { ...session.authInfo, ...authInfo };\n            await this.save();\n            return true;\n        }\n        return false;\n    }\n    async addSession(session) {\n        const newSession = {\n            id: session.id || crypto.randomUUID(),\n            authInfo: session.authInfo || {},\n            isDisabled: session.isDisabled ?? false,\n            lastUsed: session.lastUsed || new Date(),\n            usageCount: session.usageCount || 0,\n            category: session.category || 'default',\n            maxConcurrent: session.maxConcurrent || 1,\n            currentConcurrent: 0,\n            nextAvailableTime: session.nextAvailableTime,\n        };\n        this.sessions.set(newSession.id, newSession);\n        await this.save();\n    }\n    async acquireSession(category, maxWaitTime = 30000) {\n        const availableSession = await this.selectNextSession(category);\n        if (availableSession) {\n            availableSession.currentConcurrent++;\n            availableSession.lastUsed = new Date();\n            availableSession.usageCount++;\n            await this.save();\n            return availableSession;\n        }\n        return new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                this.removeFromWaitingQueue(category, resolve);\n                reject(new Error('Max wait time exceeded'));\n            }, maxWaitTime);\n            const clearTimeoutAndResolve = (value) => {\n                clearTimeout(timeout);\n                resolve(value);\n            };\n            const clearTimeoutAndReject = (reason) => {\n                clearTimeout(timeout);\n                reject(reason);\n            };\n            this.addToWaitingQueue(category, clearTimeoutAndResolve, clearTimeoutAndReject);\n        });\n    }\n    async releaseSession(sessionId) {\n        const session = this.sessions.get(sessionId);\n        if (session) {\n            session.currentConcurrent = Math.max(0, session.currentConcurrent - 1);\n            await this.save();\n            const category = session.category;\n            if (this.waitingQueue.has(category) && this.waitingQueue.get(category).length > 0) {\n                const { resolve } = this.waitingQueue.get(category).shift();\n                const nextSession = await this.selectNextSession(category);\n                if (nextSession) {\n                    nextSession.currentConcurrent++;\n                    nextSession.lastUsed = new Date();\n                    nextSession.usageCount++;\n                    await this.save();\n                    resolve(nextSession);\n                }\n                else {\n                    resolve(null);\n                }\n            }\n        }\n    }\n    async selectNextSession(category) {\n        const availableSessions = Array.from(this.sessions.values()).filter(session => !session.isDisabled &&\n            session.currentConcurrent < session.maxConcurrent &&\n            (!session.nextAvailableTime || session.nextAvailableTime <= new Date()) &&\n            (!category || session.category === category));\n        if (availableSessions.length === 0)\n            return undefined;\n        return availableSessions.reduce((prev, current) => (prev.usageCount < current.usageCount) ? prev : current);\n    }\n    addToWaitingQueue(category, resolve, reject) {\n        const key = category || 'default';\n        if (!this.waitingQueue.has(key)) {\n            this.waitingQueue.set(key, []);\n        }\n        this.waitingQueue.get(key).push({ resolve, reject });\n    }\n    removeFromWaitingQueue(category, resolve) {\n        const key = category || 'default';\n        if (this.waitingQueue.has(key)) {\n            const index = this.waitingQueue.get(key).findIndex(item => item.resolve === resolve);\n            if (index !== -1) {\n                this.waitingQueue.get(key).splice(index, 1);\n            }\n        }\n    }\n}\n\nexports.SessionService = SessionService;\n","dependencies":{"local":[],"thirdParty":[],"dynamic":[],"require":[],"core":["fs/promises","path"]},"isDynamic":false,"importType":"import"}],"thirdParty":["crawlee"],"dynamic":[],"require":[],"core":[]},"isDynamic":false,"importType":"import"},{"original":"./types","resolved":"github-search-crawler/types.ts","content":null,"dependencies":[],"isDynamic":false,"importType":"import"},{"original":"@devnest/core","resolved":"../../core/dist/index.js","content":null,"dependencies":[],"isDynamic":false,"importType":"import"},{"original":"./popularity-search-service","resolved":"github-search-crawler/popularity-search-service.ts","content":"import { getPopularityTechs, PopularTechnologyName, PopularTechnologyPackageName } from '../popularity';\nimport { SearchParams, RepositoryData } from './types';\nimport { crawlGitHub } from './crawler';\nimport { SessionService } from '@devnest/core';\nimport { checkNpmPackages, PackageResult, combineRegex } from '../package-checker';\n\n/**\n * Options for the popularity search service\n */\ninterface PopularitySearchOptions {\n    technologies: PopularTechnologyName[];\n    monthsAgo?: number;\n    maxPages?: number;\n    onlyFirstPackage?: boolean;\n}\n\n/**\n * Result of the popularity search service\n */\ninterface PopularitySearchResult {\n    repositories: RepositoryData[];\n    packageVersions: PackageResult[];\n}\n\n/**\n * Searches for repositories using popular technologies\n * @param options - Search options including technologies, months ago for version check, and max pages to crawl\n * @param sessionService - Session service for authentication\n * @returns Promise resolving to PopularitySearchResult\n */\nexport async function searchPopularTechnologies(\n    options: PopularitySearchOptions,\n    sessionService: SessionService\n): Promise<PopularitySearchResult> {\n    const { technologies, monthsAgo = 6, maxPages = 5, onlyFirstPackage = true } = options;\n    const { packageNames, packageVersions } = await getPackageInfo(technologies, { monthsAgo, onlyFirstPackage })\n    const regexPatterns = combineRegex(packageVersions);\n\n    // 4. Create search query using the combined regex\n    const searchQuery = (onlyFirstPackage ? packageNames.slice(1).join(\" \") + \" \" : \"\") + regexPatterns.map(regex => `/${regex.source}/`).join(' ') + ' -is:fork';\n    console.log(\"searchQuery\", searchQuery);\n\n    const searchParams: SearchParams = {\n        query: searchQuery,\n        type: 'code',\n        maxPages: maxPages\n    };\n\n    // 6. Perform the GitHub search\n    const searchResults = await crawlGitHub(searchParams, sessionService);\n\n    // 7. Return the combined results\n    return {\n        repositories: searchResults.repositories,\n        packageVersions\n    };\n}\n\n/**\n * Retrieves package information for specified technologies\n * @param technologies - Array of technology names to fetch package info for\n * @param monthsAgo - Number of months to look back for package versions\n * @returns Promise resolving to an array of PackageResult\n */\nasync function getPackageInfo(\n    technologies: PopularTechnologyName[],\n    options: {\n        monthsAgo?: number;\n        onlyFirstPackage?: boolean;\n    } = {}\n): Promise<{ packageVersions: PackageResult[], packageNames: PopularTechnologyPackageName[] }> {\n    const allTechs = getPopularityTechs();\n    const selectedTechs = allTechs.filter(tech => technologies.includes(tech.name as PopularTechnologyName));\n    const packageNames = selectedTechs.map(tech => tech.packageName);\n\n    return {\n        packageVersions: await checkNpmPackages(packageNames, options),\n        packageNames\n    };\n}\n","dependencies":{"local":[{"original":"../popularity","resolved":"popularity.ts","content":null,"dependencies":[],"isDynamic":false,"importType":"import"},{"original":"./types","resolved":"github-search-crawler/types.ts","content":null,"dependencies":[],"isDynamic":false,"importType":"import"},{"original":"./crawler","resolved":"github-search-crawler/crawler.ts","content":null,"dependencies":[],"isDynamic":false,"importType":"import"},{"original":"@devnest/core","resolved":"../../core/dist/index.js","content":null,"dependencies":[],"isDynamic":false,"importType":"import"},{"original":"../package-checker","resolved":"package-checker.ts","content":null,"dependencies":[],"isDynamic":false,"importType":"import"}],"thirdParty":[],"dynamic":[],"require":[],"core":[]},"isDynamic":false,"importType":"import"}],"thirdParty":[],"dynamic":[],"require":[],"core":[]},"isDynamic":false,"importType":"import"}],"thirdParty":[],"dynamic":[],"require":[],"core":[]},"content":"export * from \"./popularity\";\nexport * from \"./package-checker\";\nexport * from \"./gitHub-oauth-service\";\nexport * from \"./github-search-crawler\";\n\n","resolves":["popularity.ts","package-checker.ts","gitHub-oauth-service.ts","github-search-crawler/index.ts","github-search-crawler/crawler.ts","github-search-crawler/types.ts","../../core/dist/index.js","github-search-crawler/popularity-search-service.ts"],"thirdParties":["crawlee"],"coreModules":["http","https","fs/promises","path"],"envVariables":{"importMeta":[],"process":[]}}