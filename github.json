{"graph":{"../../core/dist/index.d.ts":[],"gitHub-oauth-service.ts":[],"github-search-crawler/crawler.ts":["../../../node_modules/.pnpm/crawlee@3.11.1/node_modules/crawlee/index.d.ts","../../core/dist/index.d.ts","github-search-crawler/types.ts"],"github-search-crawler/index.ts":["../../core/dist/index.d.ts","github-search-crawler/crawler.ts","github-search-crawler/popularity-search-service.ts","github-search-crawler/types.ts"],"github-search-crawler/popularity-search-service.ts":["../../core/dist/index.d.ts","github-search-crawler/crawler.ts","github-search-crawler/types.ts","package-checker.ts","popularity.ts"],"github-search-crawler/types.ts":[],"index.ts":["gitHub-oauth-service.ts","github-search-crawler/index.ts","package-checker.ts","popularity.ts"],"package-checker.ts":[],"popularity.ts":[]},"entry":"/cloudide/workspace/toolbox/packages/github/src/index.ts","sep":"/","usedShadcnComponents":[],"usedCoreModules":[],"usedThirdPartyModules":["crawlee"],"commonDirectory":"/cloudide/workspace/toolbox/packages/github/src","usedModulesContent":[["/cloudide/workspace/toolbox/packages/github/src/index.ts","export * from \"./popularity\";\nexport * from \"./package-checker\";\nexport * from \"./gitHub-oauth-service\";\nexport * from \"./github-search-crawler\";"],["/cloudide/workspace/toolbox/packages/github/src/github-search-crawler/index.ts","import { crawlGitHub } from './crawler';\nimport { SearchParams } from './types';\nimport { SessionService } from '@devnest/core';\nimport { searchPopularTechnologies } from './popularity-search-service';\n\nasync function main() {\n    const searchParams: SearchParams = {\n        query: \"/next/\",\n        type: 'code',\n        maxPages: 2,\n    };\n    const sessionService = new SessionService();\n    await sessionService.addSession({\n        category: 'github',\n        maxConcurrent: 5,\n        id: 'github-1',\n        authInfo: {\n            \"accept\": \"application/json\",\n            \"accept-language\": \"zh-CN,zh;q=0.9\",\n            \"priority\": \"u=1, i\",\n            \"sec-ch-ua\": \"\\\"Not)A;Brand\\\";v=\\\"99\\\", \\\"Google Chrome\\\";v=\\\"127\\\", \\\"Chromium\\\";v=\\\"127\\\"\",\n            \"sec-ch-ua-mobile\": \"?0\",\n            \"sec-ch-ua-platform\": \"\\\"Windows\\\"\",\n            \"sec-fetch-dest\": \"empty\",\n            \"sec-fetch-mode\": \"cors\",\n            \"sec-fetch-site\": \"same-origin\",\n            \"x-github-target\": \"dotcom\",\n            \"x-react-router\": \"json\",\n            \"x-requested-with\": \"XMLHttpRequest\",\n            \"cookie\": \"_octo=GH1.1.919065573.1702386987; _device_id=3fab0228c7a1bcb232fa79a2fe311454; saved_user_sessions=33978392%3AW4ra8WefHrzFPqgh4nHIVsYhf6mvOtT-Hd0QniN-_PsLJerU; user_session=W4ra8WefHrzFPqgh4nHIVsYhf6mvOtT-Hd0QniN-_PsLJerU; __Host-user_session_same_site=W4ra8WefHrzFPqgh4nHIVsYhf6mvOtT-Hd0QniN-_PsLJerU; logged_in=yes; dotcom_user=842797524; color_mode=%7B%22color_mode%22%3A%22auto%22%2C%22light_theme%22%3A%7B%22name%22%3A%22light%22%2C%22color_mode%22%3A%22light%22%7D%2C%22dark_theme%22%3A%7B%22name%22%3A%22dark%22%2C%22color_mode%22%3A%22dark%22%7D%7D; preferred_color_mode=light; tz=Asia%2FShanghai; _gh_sess=N94hHAyXEn7Kj8ZmwiCssDF3Wl%2FJODcOy5w3Rs9yXo%2FS1uDsYEGVFPVeRBp6uGxegyzOGZz9l6bEjHlptXjO0%2F0BbosAt11bp%2F1SdnpkE4UYluT%2BwU0133kADS44zXXw63kTxtJ0o7XWlP1Ra1wlTbhfAMUxVm%2BSLH7RBCm%2BQy7EMBpVMLWw5EqotY5NopIw1VMiyWdDmf%2F6sZIVWzfjCqfcTEQzcWbGyBTCdIMwxT6aiaKsOR7TYJvBqtLde7fcuTtQYpdxajEF%2FkzoGsObvrGv65lC5vZyM7tMtQc6jy%2F%2FB%2BFZYEcOMxZPgryedt4G0XcSJGI8essD9SPE3A9yaPZqH8UaUIDIyTTzGPF5AqifqteVnTwIFibqM%2BeSglKA5zJK3dmhPgiSytaheqos%2BshJ6Ggj2T5luzzjEPNcYc89%2FEIwpmqt5UOjfzrby041HrHuj1qBVBz%2F9BPY915di4R1uAmVLtiYoicfPulDliKNmY53gcI7MswQOMUvEGM1n8FHgGLE0CRW4PmwNS4RT6nCv00Uk6gwwJSOFp7ha5yPN90u--pOcWfvvXi0m5KwwZ--1OaYOTMTzqeM8HkK43Uj%2Bw%3D%3D\",\n            \"Referer\": \"https://github.com/search?q=lodash+e&type=repositories\",\n            \"Referrer-Policy\": \"strict-origin-when-cross-origin\"\n        },\n        isDisabled: false,\n        lastUsed: new Date(),\n        usageCount: 0\n    });\n    await sessionService.init();\n     await searchPopularTechnologies({\n        technologies: ['Next.js', \"Tailwind CSS\", \"LangChain\", \"LangGraph\"],\n        monthsAgo: 6,\n        maxPages: 2\n    }, sessionService)\n\n    // try {\n    //     const result = await crawlGitHub(searchParams, sessionService);\n\n    //     console.log(`Repositories crawled: ${result.repositories.length}`);\n    //     console.log('First 5 repositories:');\n    //     result.repositories.slice(0, 5).forEach((repo, index) => {\n    //         console.log(`\\n${index + 1}. ${repo.id}`);\n\n    //     });\n    // } catch (error) {\n    //     console.error('An error occurred:', error);\n    // }\n}\n\nmain();"],["/cloudide/workspace/toolbox/packages/github/src/github-search-crawler/crawler.ts","import { SearchParams, CrawlerResult, } from './types';\nimport { SessionService } from '@devnest/core';\nimport { HttpCrawler, HttpCrawlingContext } from 'crawlee';\n\nexport async function crawlGitHub(params: SearchParams, sessionService?: SessionService): Promise<CrawlerResult> {\n    const { query, type, maxPages } = params;\n\n    const result: CrawlerResult = { repositories: [], };\n\n    const crawler = new HttpCrawler({\n        maxConcurrency: 5,\n        async requestHandler({ request, json }: HttpCrawlingContext) {\n            const getFullName = repo => repo.repo_nwo || repo.hl_name.replace(/&#x2F;/g, '/').replace(/<em>|<\\/em>/g, '')\n            const repositories = json.payload.results.map(repo => ({ id: repo.id || repo.repo_id, fullName: getFullName(repo) }));\n            result.repositories.push(...repositories);\n\n            // Enqueue next pages\n            if (request.userData.page === 1) {\n                const baseUrl = request.url.split('&p=')[0];\n                const requests: any = [];\n\n                for (let p = 2; p <= Math.min(maxPages, json.payload.page_count); p++) {\n                    requests.push({\n                        url: `${baseUrl}&p=${p}`,\n                        userData: { ...request.userData, page: p }\n                    });\n                }\n\n                await crawler.addRequests(requests);\n            }\n        },\n        preNavigationHooks: [\n            async ({ request, }) => {\n                const session = await sessionService?.acquireSession(\"github\");\n                if (session) {\n                    Object.assign(request.headers as object, session.authInfo);\n                    request.userData.session = session;\n                }\n            }\n        ],\n        postNavigationHooks: [\n            async ({ request }) => {\n                const session = request.userData.session;\n                if (session) {\n                    await sessionService?.releaseSession(session.id);\n                }\n            }\n        ],\n    });\n\n    const baseUrl = 'https://github.com/search';\n    const searchParams = new URLSearchParams({\n        q: query,\n        type,\n        p: '1',\n    });\n\n    await crawler.addRequests([{\n        url: `${baseUrl}?${searchParams.toString()}`,\n        userData: { page: 1 },\n        label: 'pagination',\n    }]);\n\n    await crawler.run();\n\n    return result;\n}\n"],["/cloudide/workspace/toolbox/packages/github/src/github-search-crawler/popularity-search-service.ts","import { getPopularityTechs, PopularTechnologyName, PopularTechnologyPackageName } from '../popularity';\nimport { SearchParams, RepositoryData } from './types';\nimport { crawlGitHub } from './crawler';\nimport { SessionService } from '@devnest/core';\nimport { checkNpmPackages, PackageResult, combineRegex } from '../package-checker';\n\n/**\n * Options for the popularity search service\n */\ninterface PopularitySearchOptions {\n    technologies: PopularTechnologyName[];\n    monthsAgo?: number;\n    maxPages?: number;\n    onlyFirstPackage?: boolean;\n}\n\n/**\n * Result of the popularity search service\n */\ninterface PopularitySearchResult {\n    repositories: RepositoryData[];\n    packageVersions: PackageResult[];\n}\n\n/**\n * Searches for repositories using popular technologies\n * @param options - Search options including technologies, months ago for version check, and max pages to crawl\n * @param sessionService - Session service for authentication\n * @returns Promise resolving to PopularitySearchResult\n */\nexport async function searchPopularTechnologies(\n    options: PopularitySearchOptions,\n    sessionService: SessionService\n): Promise<PopularitySearchResult> {\n    const { technologies, monthsAgo = 6, maxPages = 5, onlyFirstPackage = true } = options;\n    const { packageNames, packageVersions } = await getPackageInfo(technologies, { monthsAgo, onlyFirstPackage })\n    const regexPatterns = combineRegex(packageVersions);\n\n    // 4. Create search query using the combined regex\n    const searchQuery = (onlyFirstPackage ? packageNames.slice(1).join(\" \") + \" \" : \"\") + regexPatterns.map(regex => `/${regex.source}/`).join(' ') + ' -is:fork';\n    console.log(\"searchQuery\", searchQuery);\n\n    const searchParams: SearchParams = {\n        query: searchQuery,\n        type: 'code',\n        maxPages: maxPages\n    };\n\n    // 6. Perform the GitHub search\n    const searchResults = await crawlGitHub(searchParams, sessionService);\n\n    // 7. Return the combined results\n    return {\n        repositories: searchResults.repositories,\n        packageVersions\n    };\n}\n\n/**\n * Retrieves package information for specified technologies\n * @param technologies - Array of technology names to fetch package info for\n * @param monthsAgo - Number of months to look back for package versions\n * @returns Promise resolving to an array of PackageResult\n */\nasync function getPackageInfo(\n    technologies: PopularTechnologyName[],\n    options: {\n        monthsAgo?: number;\n        onlyFirstPackage?: boolean;\n    } = {}\n): Promise<{ packageVersions: PackageResult[], packageNames: PopularTechnologyPackageName[] }> {\n    const allTechs = getPopularityTechs();\n    const selectedTechs = allTechs.filter(tech => technologies.includes(tech.name as PopularTechnologyName));\n    const packageNames = selectedTechs.map(tech => tech.packageName);\n\n    return {\n        packageVersions: await checkNpmPackages(packageNames, options),\n        packageNames\n    };\n}\n"]],"moduleName":"github","componentType":"lib"}